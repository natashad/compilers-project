
CSC488 - A2 -- Design Document. (I WILL MAKE THIS NOT A TXT EVENTUALLY)

When designing the grammar, I started by just simply following the language specification, correcting obvious problems as I went.
The first real variation from the given specification was splitting up grammar rules that could lead to multiple parse trees.
For instance, "Statement --> Statement Statement". In order to disambiguate cases like these, I split up rules with two recursive references into another rule.
Therefore with the example of Statement, I created StatementList --> Statement, Statement StatementList. Then wherever there were references to Statement in the
Language reference rules, I replaced them with StatementList.
Another thing I changed was replacing all variablenames, parameternames, functionnames, prcedurenames etc... with IDENT in place.

The part of the grammar I found most challenging was the expressions. Specifically, expressions needed to be defined in a way to allow for operator precedence.
The way that I handled this was by starting at a base form that I called baseExpression. This base form defined some of the basest form of expressions: Terminals, argument lists, things in parantheses etc... From there, I built up at every step starting with the operator of highest precedence, including in its rules a rule to generate the previous type and then a rule using the previous type with this current operator. For example: the unary minus has highest precedence and so I did UnaryExpression --> BaseExpression | MINUS BaseExpression. In this way, I built up all the way to 'OR' which had the lowest precedence. Therefore, OrExpression was inclusive of all other generatable expressions, as well as an OR between them.

In order to maintain associativity from Left to Right for multiplication, addition etc... My rules for those have a recursive rule as the left most non-terminal on the RHS of the rule. This ensures the left to right associativity.